/*
 * southbound
 *
 * API generated from yang definitions: [aaa-encrypt-service-config,cli-topology,cli-translate-registry,cluster-singleton-service-impl,cluster-singleton-service-spi,config,fake,general-entity,ietf-inet-types,ietf-netconf,ietf-netconf-monitoring,ietf-netconf-monitoring-extension,ietf-netconf-notifications,ietf-yang-library,ietf-yang-types,journal,nc-notifications,netconf-keystore,netconf-node-inventory,netconf-node-topology,network-topology,network-topology,notifications,opendaylight-config-dom-datastore,opendaylight-entity-ownership-service,opendaylight-inmemory-datastore-provider,opendaylight-inventory,opendaylight-legacy-entity-ownership-service-provider,opendaylight-md-sal-common,opendaylight-md-sal-dom,opendaylight-operational-dom-datastore,rpc-context,yang-ext]
 *
 * API version: 4.2.0.frinx
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger_southbound

// Optional[ This is the model of an abstract topology. A topology contains nodes and links. Each topology MUST be identified by unique topology-id for reason that a network could contain many topologies. ] REF:Optional.empty
type NetworkTopologyNetworktopologyTopology struct {
	// Optional[The list of network nodes defined for the topology.] REF:Optional.empty
	Node []NetworkTopologyNetworktopologyTopologyNode `json:"node,omitempty"`
	// Optional[This container is used to identify the type, or types (as a topology can support several types simultaneously), of the topology. Topology types are the subject of several integrity constraints that an implementing server can validate in order to maintain integrity of the datastore. Topology types are indicated through separate data nodes; the set of topology types is expected to increase over time. To add support for a new topology, an augmenting module needs to augment this container with a new empty optional container to indicate the new topology type. The use of a container allows to indicate a subcategorization of topology types. The container SHALL NOT be augmented with any data nodes that serve a purpose other than identifying a particular topology type. ] REF:Optional.empty
	TopologyTypes *NetworkTopologyNetworktopologyTopologyTopologyTypes `json:"topology-types,omitempty"`
	// Optional[ It is presumed that a datastore will contain many topologies. To distinguish between topologies it is vital to have UNIQUE topology identifiers. ] REF:Optional.empty
	TopologyId string `json:"topology-id,omitempty"`
	// Optional[ A Network Link connects a by Local (Source) node and a Remote (Destination) Network Nodes via a set of the nodes' termination points. As it is possible to have several links between the same source and destination nodes, and as a link could potentially be re-homed between termination points, to ensure that we would always know to distinguish between links, every link is identified by a dedicated link identifier. Note that a link models a point-to-point link, not a multipoint link. Layering dependencies on links in underlay topologies are not represented as the layering information of nodes and of termination points is sufficient. ] REF:Optional.empty
	Link []NetworkTopologyNetworktopologyTopologyLink `json:"link,omitempty"`
	// Optional[ Indicates whether the topology is configurable by clients, or whether it is provided by the server.  This leaf is  populated by the server implementing the model. It is set to false for topologies that are created by a client; it is set to true otherwise.  If it is set to true, any attempt to edit the topology MUST be rejected. ] REF:Optional.empty
	ServerProvided bool `json:"server-provided,omitempty"`
	// Optional[Identifies the topology, or topologies, that this topology is dependent on.] REF:Optional.empty
	UnderlayTopology []NetworkTopologyNetworktopologyTopologyUnderlayTopology `json:"underlay-topology,omitempty"`
}
