/*
 * unified
 *
 * API generated from yang definitions: [fake,frinx-acl-extension,frinx-bfd,frinx-bfd-extension,frinx-bgp-extension,frinx-cdp,frinx-cisco-if-extension,frinx-cisco-mpls-te-extension,frinx-cisco-ospf-extension,frinx-cisco-pf-interfaces-extension,frinx-damping,frinx-dasan-vlan-extension,frinx-event-types,frinx-evpn,frinx-evpn-types,frinx-hsrp,frinx-if-aggregate-extension,frinx-isis-extension,frinx-juniper-if-aggregate-extension,frinx-juniper-if-extension,frinx-juniper-pf-interfaces-extension,frinx-juniper-probes-extension,frinx-l3ipvlan,frinx-lacp-lag-member,frinx-logging,frinx-mpls-ldp-extension,frinx-mpls-rsvp-extension,frinx-netflow,frinx-openconfig-acl,frinx-openconfig-bfd,frinx-openconfig-bgp,frinx-openconfig-bgp-policy,frinx-openconfig-bgp-types,frinx-openconfig-extensions,frinx-openconfig-if-aggregate,frinx-openconfig-if-ethernet,frinx-openconfig-if-ip,frinx-openconfig-if-ip-ext,frinx-openconfig-inet-types,frinx-openconfig-interfaces,frinx-openconfig-isis,frinx-openconfig-isis-lsdb-types,frinx-openconfig-isis-policy,frinx-openconfig-isis-types,frinx-openconfig-lacp,frinx-openconfig-lldp,frinx-openconfig-lldp-types,frinx-openconfig-local-routing,frinx-openconfig-mpls,frinx-openconfig-mpls-ldp,frinx-openconfig-mpls-rsvp,frinx-openconfig-mpls-types,frinx-openconfig-network-instance,frinx-openconfig-network-instance-l3,frinx-openconfig-network-instance-policy,frinx-openconfig-network-instance-types,frinx-openconfig-ospf-policy,frinx-openconfig-ospf-types,frinx-openconfig-ospfv2,frinx-openconfig-packet-match,frinx-openconfig-packet-match-types,frinx-openconfig-platform,frinx-openconfig-platform-linecard,frinx-openconfig-platform-port,frinx-openconfig-platform-transceiver,frinx-openconfig-platform-types,frinx-openconfig-policy-forwarding,frinx-openconfig-policy-types,frinx-openconfig-probes,frinx-openconfig-probes-types,frinx-openconfig-qos,frinx-openconfig-qos-types,frinx-openconfig-rib-bgp,frinx-openconfig-rib-bgp-ext,frinx-openconfig-rib-bgp-types,frinx-openconfig-routing-policy,frinx-openconfig-transport-types,frinx-openconfig-types,frinx-openconfig-vlan,frinx-openconfig-vlan-types,frinx-openconfig-yang-types,frinx-ospf-extension,frinx-qos-extension,frinx-snmp,frinx-uniconfig-topology,iana-if-type,ietf-inet-types,ietf-interfaces,ietf-yang-types,network-topology,network-topology,unified-topology,yang-ext]
 *
 * API version: 4.2.0.frinx
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger_unified

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
)

// Linger please
var (
	_ context.Context
)

type FrinxOpenconfigBgpPolicyApiService service

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.routingpolicy.definedsets.BgpDefinedSets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSets(ctx context.Context, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.aspathsettop.AsPathSets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSets(ctx context.Context, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.aspathsettop.aspathsets.AsPathSet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param asPathSetName Id of as-path-set
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSetsAsPathSet(ctx context.Context, asPathSetName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/frinx-openconfig-bgp-policy:as-path-set/{as-path-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"as-path-set-name"+"}", fmt.Sprintf("%v", asPathSetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.aspathsettop.aspathsets.aspathset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param asPathSetName Id of as-path-set
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSetsAsPathSetConfig(ctx context.Context, asPathSetName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/frinx-openconfig-bgp-policy:as-path-set/{as-path-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"as-path-set-name"+"}", fmt.Sprintf("%v", asPathSetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.communitysettop.CommunitySets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySets(ctx context.Context, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.communitysettop.communitysets.CommunitySet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param communitySetName Id of community-set
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySetsCommunitySet(ctx context.Context, communitySetName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/frinx-openconfig-bgp-policy:community-set/{community-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"community-set-name"+"}", fmt.Sprintf("%v", communitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.communitysettop.communitysets.communityset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param communitySetName Id of community-set
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySetsCommunitySetConfig(ctx context.Context, communitySetName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/frinx-openconfig-bgp-policy:community-set/{community-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"community-set-name"+"}", fmt.Sprintf("%v", communitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.extcommunitysettop.ExtCommunitySets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySets(ctx context.Context, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.extcommunitysettop.extcommunitysets.ExtCommunitySet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extCommunitySetName Id of ext-community-set
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySetsExtCommunitySet(ctx context.Context, extCommunitySetName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/frinx-openconfig-bgp-policy:ext-community-set/{ext-community-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"ext-community-set-name"+"}", fmt.Sprintf("%v", extCommunitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.extcommunitysettop.extcommunitysets.extcommunityset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extCommunitySetName Id of ext-community-set
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySetsExtCommunitySetConfig(ctx context.Context, extCommunitySetName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/frinx-openconfig-bgp-policy:ext-community-set/{ext-community-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"ext-community-set-name"+"}", fmt.Sprintf("%v", extCommunitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.bgpactionstop.BgpActions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActions(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.bgpactionstop.bgpactions.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.aspathprependtop.SetAsPathPrepend
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetAsPathPrepend(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-as-path-prepend/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.aspathprependtop.setaspathprepend.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetAsPathPrependConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-as-path-prepend/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setcommunityactiontop.SetCommunity
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunity(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setcommunityactiontop.setcommunity.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setcommunityinlinetop.Inline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityInline(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:inline/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setcommunityinlinetop.inline.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityInlineConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:inline/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setcommunityreferencetop.Reference
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityReference(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:reference/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setcommunityreferencetop.reference.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityReferenceConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:reference/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setextcommunityactiontop.SetExtCommunity
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunity(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setextcommunityactiontop.setextcommunity.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setextcommunityinlinetop.Inline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityInline(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:inline/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setextcommunityinlinetop.inline.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityInlineConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:inline/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setextcommunityreferencetop.Reference
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityReference(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:reference/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.setextcommunityreferencetop.reference.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityReferenceConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:reference/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.bgpconditionstop.BgpConditions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditions(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.aspathlengthtop.AsPathLength
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsAsPathLength(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:as-path-length/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.aspathlengthtop.aspathlength.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsAsPathLengthConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:as-path-length/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.communitycounttop.CommunityCount
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsCommunityCount(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:community-count/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.communitycounttop.communitycount.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsCommunityCountConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:community-count/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.bgpconditionstop.bgpconditions.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.matchaspathtop.MatchAsPathSet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchAsPathSet(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-as-path-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.matchaspathtop.matchaspathset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchAsPathSetConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-as-path-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.matchcommunitytop.MatchCommunitySet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchCommunitySet(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-community-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.matchcommunitytop.matchcommunityset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchCommunitySetConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-community-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.matchextcommunitytop.MatchExtCommunitySet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchExtCommunitySet(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-ext-community-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
removes frinx.openconfig.bgp.policy.matchextcommunitytop.matchextcommunityset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) DeleteFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchExtCommunitySetConfig(ctx context.Context, name string, statementName string, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-ext-community-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeId

@return FrinxOpenconfigBgpPolicyRoutingpolicyDefinedsetsBgpDefinedSetsResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSets(ctx context.Context, nodeId string) (FrinxOpenconfigBgpPolicyRoutingpolicyDefinedsetsBgpDefinedSetsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyRoutingpolicyDefinedsetsBgpDefinedSetsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyRoutingpolicyDefinedsetsBgpDefinedSetsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeId

@return FrinxOpenconfigBgpPolicyAspathsettopAsPathSetsResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSets(ctx context.Context, nodeId string) (FrinxOpenconfigBgpPolicyAspathsettopAsPathSetsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyAspathsettopAsPathSetsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyAspathsettopAsPathSetsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param asPathSetName Id of as-path-set
 * @param nodeId

@return FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAsPathSetResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSetsAsPathSet(ctx context.Context, asPathSetName string, nodeId string) (FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAsPathSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAsPathSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/frinx-openconfig-bgp-policy:as-path-set/{as-path-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"as-path-set-name"+"}", fmt.Sprintf("%v", asPathSetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAsPathSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param asPathSetName Id of as-path-set
 * @param nodeId

@return FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAspathsetConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSetsAsPathSetConfig(ctx context.Context, asPathSetName string, nodeId string) (FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAspathsetConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAspathsetConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/frinx-openconfig-bgp-policy:as-path-set/{as-path-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"as-path-set-name"+"}", fmt.Sprintf("%v", asPathSetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAspathsetConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeId

@return FrinxOpenconfigBgpPolicyCommunitysettopCommunitySetsResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySets(ctx context.Context, nodeId string) (FrinxOpenconfigBgpPolicyCommunitysettopCommunitySetsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyCommunitysettopCommunitySetsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyCommunitysettopCommunitySetsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param communitySetName Id of community-set
 * @param nodeId

@return FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitySetResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySetsCommunitySet(ctx context.Context, communitySetName string, nodeId string) (FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitySetResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitySetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/frinx-openconfig-bgp-policy:community-set/{community-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"community-set-name"+"}", fmt.Sprintf("%v", communitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitySetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param communitySetName Id of community-set
 * @param nodeId

@return FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitysetConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySetsCommunitySetConfig(ctx context.Context, communitySetName string, nodeId string) (FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitysetConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitysetConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/frinx-openconfig-bgp-policy:community-set/{community-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"community-set-name"+"}", fmt.Sprintf("%v", communitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitysetConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeId

@return FrinxOpenconfigBgpPolicyExtcommunitysettopExtCommunitySetsResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySets(ctx context.Context, nodeId string) (FrinxOpenconfigBgpPolicyExtcommunitysettopExtCommunitySetsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyExtcommunitysettopExtCommunitySetsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyExtcommunitysettopExtCommunitySetsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extCommunitySetName Id of ext-community-set
 * @param nodeId

@return FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtCommunitySetResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySetsExtCommunitySet(ctx context.Context, extCommunitySetName string, nodeId string) (FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtCommunitySetResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtCommunitySetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/frinx-openconfig-bgp-policy:ext-community-set/{ext-community-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"ext-community-set-name"+"}", fmt.Sprintf("%v", extCommunitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtCommunitySetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extCommunitySetName Id of ext-community-set
 * @param nodeId

@return FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtcommunitysetConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySetsExtCommunitySetConfig(ctx context.Context, extCommunitySetName string, nodeId string) (FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtcommunitysetConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtcommunitysetConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/frinx-openconfig-bgp-policy:ext-community-set/{ext-community-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"ext-community-set-name"+"}", fmt.Sprintf("%v", extCommunitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtcommunitysetConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyBgpactionstopBgpActionsResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActions(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyBgpactionstopBgpActionsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyBgpactionstopBgpActionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyBgpactionstopBgpActionsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyBgpactionstopBgpactionsConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyBgpactionstopBgpactionsConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyBgpactionstopBgpactionsConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyBgpactionstopBgpactionsConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyAspathprependtopSetAsPathPrependResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetAsPathPrepend(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyAspathprependtopSetAsPathPrependResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyAspathprependtopSetAsPathPrependResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-as-path-prepend/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyAspathprependtopSetAsPathPrependResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyAspathprependtopSetaspathprependConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetAsPathPrependConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyAspathprependtopSetaspathprependConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyAspathprependtopSetaspathprependConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-as-path-prepend/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyAspathprependtopSetaspathprependConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetcommunityactiontopSetCommunityResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunity(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetcommunityactiontopSetCommunityResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetcommunityactiontopSetCommunityResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetcommunityactiontopSetCommunityResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetcommunityactiontopSetcommunityConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetcommunityactiontopSetcommunityConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetcommunityactiontopSetcommunityConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetcommunityactiontopSetcommunityConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityInline(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:inline/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityInlineConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:inline/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityReference(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:reference/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityReferenceConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:reference/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetextcommunityactiontopSetExtCommunityResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunity(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetextcommunityactiontopSetExtCommunityResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetextcommunityactiontopSetExtCommunityResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetextcommunityactiontopSetExtCommunityResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetextcommunityactiontopSetextcommunityConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetextcommunityactiontopSetextcommunityConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetextcommunityactiontopSetextcommunityConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetextcommunityactiontopSetextcommunityConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityInline(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:inline/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityInlineConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:inline/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityReference(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:reference/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityReferenceConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:reference/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyBgpconditionstopBgpConditionsResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditions(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyBgpconditionstopBgpConditionsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyBgpconditionstopBgpConditionsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyBgpconditionstopBgpConditionsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyAspathlengthtopAsPathLengthResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsAsPathLength(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyAspathlengthtopAsPathLengthResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyAspathlengthtopAsPathLengthResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:as-path-length/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyAspathlengthtopAsPathLengthResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyAspathlengthtopAspathlengthConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsAsPathLengthConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyAspathlengthtopAspathlengthConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyAspathlengthtopAspathlengthConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:as-path-length/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyAspathlengthtopAspathlengthConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyCommunitycounttopCommunityCountResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsCommunityCount(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyCommunitycounttopCommunityCountResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyCommunitycounttopCommunityCountResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:community-count/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyCommunitycounttopCommunityCountResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyCommunitycounttopCommunitycountConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsCommunityCountConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyCommunitycounttopCommunitycountConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyCommunitycounttopCommunitycountConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:community-count/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyCommunitycounttopCommunitycountConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyBgpconditionstopBgpconditionsConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyBgpconditionstopBgpconditionsConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyBgpconditionstopBgpconditionsConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyBgpconditionstopBgpconditionsConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyMatchaspathtopMatchAsPathSetResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchAsPathSet(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyMatchaspathtopMatchAsPathSetResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyMatchaspathtopMatchAsPathSetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-as-path-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyMatchaspathtopMatchAsPathSetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyMatchaspathtopMatchaspathsetConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchAsPathSetConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyMatchaspathtopMatchaspathsetConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyMatchaspathtopMatchaspathsetConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-as-path-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyMatchaspathtopMatchaspathsetConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyMatchcommunitytopMatchCommunitySetResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchCommunitySet(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyMatchcommunitytopMatchCommunitySetResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyMatchcommunitytopMatchCommunitySetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-community-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyMatchcommunitytopMatchCommunitySetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyMatchcommunitytopMatchcommunitysetConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchCommunitySetConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyMatchcommunitytopMatchcommunitysetConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyMatchcommunitytopMatchcommunitysetConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-community-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyMatchcommunitytopMatchcommunitysetConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchExtCommunitySetResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchExtCommunitySet(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchExtCommunitySetResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchExtCommunitySetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-ext-community-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchExtCommunitySetResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param nodeId

@return FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchextcommunitysetConfigResponse
*/
func (a *FrinxOpenconfigBgpPolicyApiService) GetFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchExtCommunitySetConfig(ctx context.Context, name string, statementName string, nodeId string) (FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchextcommunitysetConfigResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchextcommunitysetConfigResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-ext-community-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchextcommunitysetConfigResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.routingpolicy.definedsets.BgpDefinedSets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param frinxOpenconfigBgpPolicyRoutingpolicyDefinedsetsBgpDefinedSetsBodyParam frinx.openconfig.bgp.policy.routingpolicy.definedsets.BgpDefinedSets to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSets(ctx context.Context, frinxOpenconfigBgpPolicyRoutingpolicyDefinedsetsBgpDefinedSetsBodyParam FrinxOpenconfigBgpPolicyRoutingpolicyDefinedsetsBgpDefinedSetsRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyRoutingpolicyDefinedsetsBgpDefinedSetsBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.aspathsettop.AsPathSets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param frinxOpenconfigBgpPolicyAspathsettopAsPathSetsBodyParam frinx.openconfig.bgp.policy.aspathsettop.AsPathSets to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSets(ctx context.Context, frinxOpenconfigBgpPolicyAspathsettopAsPathSetsBodyParam FrinxOpenconfigBgpPolicyAspathsettopAsPathSetsRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyAspathsettopAsPathSetsBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.aspathsettop.aspathsets.AsPathSet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param asPathSetName Id of as-path-set
 * @param frinxOpenconfigBgpPolicyAspathsettopAspathsetsAsPathSetBodyParam frinx.openconfig.bgp.policy.aspathsettop.aspathsets.AsPathSet to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSetsAsPathSet(ctx context.Context, asPathSetName string, frinxOpenconfigBgpPolicyAspathsettopAspathsetsAsPathSetBodyParam FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAsPathSetRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/frinx-openconfig-bgp-policy:as-path-set/{as-path-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"as-path-set-name"+"}", fmt.Sprintf("%v", asPathSetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyAspathsettopAspathsetsAsPathSetBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.aspathsettop.aspathsets.aspathset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param asPathSetName Id of as-path-set
 * @param frinxOpenconfigBgpPolicyAspathsettopAspathsetsAspathsetConfigBodyParam frinx.openconfig.bgp.policy.aspathsettop.aspathsets.aspathset.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsAsPathSetsAsPathSetConfig(ctx context.Context, asPathSetName string, frinxOpenconfigBgpPolicyAspathsettopAspathsetsAspathsetConfigBodyParam FrinxOpenconfigBgpPolicyAspathsettopAspathsetsAspathsetConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:as-path-sets/frinx-openconfig-bgp-policy:as-path-set/{as-path-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"as-path-set-name"+"}", fmt.Sprintf("%v", asPathSetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyAspathsettopAspathsetsAspathsetConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.communitysettop.CommunitySets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param frinxOpenconfigBgpPolicyCommunitysettopCommunitySetsBodyParam frinx.openconfig.bgp.policy.communitysettop.CommunitySets to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySets(ctx context.Context, frinxOpenconfigBgpPolicyCommunitysettopCommunitySetsBodyParam FrinxOpenconfigBgpPolicyCommunitysettopCommunitySetsRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyCommunitysettopCommunitySetsBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.communitysettop.communitysets.CommunitySet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param communitySetName Id of community-set
 * @param frinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitySetBodyParam frinx.openconfig.bgp.policy.communitysettop.communitysets.CommunitySet to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySetsCommunitySet(ctx context.Context, communitySetName string, frinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitySetBodyParam FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitySetRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/frinx-openconfig-bgp-policy:community-set/{community-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"community-set-name"+"}", fmt.Sprintf("%v", communitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitySetBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.communitysettop.communitysets.communityset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param communitySetName Id of community-set
 * @param frinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitysetConfigBodyParam frinx.openconfig.bgp.policy.communitysettop.communitysets.communityset.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsCommunitySetsCommunitySetConfig(ctx context.Context, communitySetName string, frinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitysetConfigBodyParam FrinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitysetConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:community-sets/frinx-openconfig-bgp-policy:community-set/{community-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"community-set-name"+"}", fmt.Sprintf("%v", communitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyCommunitysettopCommunitysetsCommunitysetConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.extcommunitysettop.ExtCommunitySets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param frinxOpenconfigBgpPolicyExtcommunitysettopExtCommunitySetsBodyParam frinx.openconfig.bgp.policy.extcommunitysettop.ExtCommunitySets to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySets(ctx context.Context, frinxOpenconfigBgpPolicyExtcommunitysettopExtCommunitySetsBodyParam FrinxOpenconfigBgpPolicyExtcommunitysettopExtCommunitySetsRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyExtcommunitysettopExtCommunitySetsBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.extcommunitysettop.extcommunitysets.ExtCommunitySet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extCommunitySetName Id of ext-community-set
 * @param frinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtCommunitySetBodyParam frinx.openconfig.bgp.policy.extcommunitysettop.extcommunitysets.ExtCommunitySet to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySetsExtCommunitySet(ctx context.Context, extCommunitySetName string, frinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtCommunitySetBodyParam FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtCommunitySetRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/frinx-openconfig-bgp-policy:ext-community-set/{ext-community-set-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"ext-community-set-name"+"}", fmt.Sprintf("%v", extCommunitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtCommunitySetBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.extcommunitysettop.extcommunitysets.extcommunityset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extCommunitySetName Id of ext-community-set
 * @param frinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtcommunitysetConfigBodyParam frinx.openconfig.bgp.policy.extcommunitysettop.extcommunitysets.extcommunityset.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyDefinedSetsBgpDefinedSetsExtCommunitySetsExtCommunitySetConfig(ctx context.Context, extCommunitySetName string, frinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtcommunitysetConfigBodyParam FrinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtcommunitysetConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:defined-sets/frinx-openconfig-bgp-policy:bgp-defined-sets/frinx-openconfig-bgp-policy:ext-community-sets/frinx-openconfig-bgp-policy:ext-community-set/{ext-community-set-name}/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"ext-community-set-name"+"}", fmt.Sprintf("%v", extCommunitySetName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyExtcommunitysettopExtcommunitysetsExtcommunitysetConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.bgpactionstop.BgpActions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyBgpactionstopBgpActionsBodyParam frinx.openconfig.bgp.policy.bgpactionstop.BgpActions to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActions(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyBgpactionstopBgpActionsBodyParam FrinxOpenconfigBgpPolicyBgpactionstopBgpActionsRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyBgpactionstopBgpActionsBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.bgpactionstop.bgpactions.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyBgpactionstopBgpactionsConfigBodyParam frinx.openconfig.bgp.policy.bgpactionstop.bgpactions.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyBgpactionstopBgpactionsConfigBodyParam FrinxOpenconfigBgpPolicyBgpactionstopBgpactionsConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyBgpactionstopBgpactionsConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.aspathprependtop.SetAsPathPrepend
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyAspathprependtopSetAsPathPrependBodyParam frinx.openconfig.bgp.policy.aspathprependtop.SetAsPathPrepend to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetAsPathPrepend(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyAspathprependtopSetAsPathPrependBodyParam FrinxOpenconfigBgpPolicyAspathprependtopSetAsPathPrependRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-as-path-prepend/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyAspathprependtopSetAsPathPrependBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.aspathprependtop.setaspathprepend.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyAspathprependtopSetaspathprependConfigBodyParam frinx.openconfig.bgp.policy.aspathprependtop.setaspathprepend.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetAsPathPrependConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyAspathprependtopSetaspathprependConfigBodyParam FrinxOpenconfigBgpPolicyAspathprependtopSetaspathprependConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-as-path-prepend/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyAspathprependtopSetaspathprependConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setcommunityactiontop.SetCommunity
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetcommunityactiontopSetCommunityBodyParam frinx.openconfig.bgp.policy.setcommunityactiontop.SetCommunity to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunity(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetcommunityactiontopSetCommunityBodyParam FrinxOpenconfigBgpPolicySetcommunityactiontopSetCommunityRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetcommunityactiontopSetCommunityBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setcommunityactiontop.setcommunity.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetcommunityactiontopSetcommunityConfigBodyParam frinx.openconfig.bgp.policy.setcommunityactiontop.setcommunity.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetcommunityactiontopSetcommunityConfigBodyParam FrinxOpenconfigBgpPolicySetcommunityactiontopSetcommunityConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetcommunityactiontopSetcommunityConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setcommunityinlinetop.Inline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetcommunityinlinetopInlineBodyParam frinx.openconfig.bgp.policy.setcommunityinlinetop.Inline to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityInline(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetcommunityinlinetopInlineBodyParam FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:inline/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetcommunityinlinetopInlineBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setcommunityinlinetop.inline.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetcommunityinlinetopInlineConfigBodyParam frinx.openconfig.bgp.policy.setcommunityinlinetop.inline.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityInlineConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetcommunityinlinetopInlineConfigBodyParam FrinxOpenconfigBgpPolicySetcommunityinlinetopInlineConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:inline/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetcommunityinlinetopInlineConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setcommunityreferencetop.Reference
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetcommunityreferencetopReferenceBodyParam frinx.openconfig.bgp.policy.setcommunityreferencetop.Reference to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityReference(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetcommunityreferencetopReferenceBodyParam FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:reference/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetcommunityreferencetopReferenceBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setcommunityreferencetop.reference.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetcommunityreferencetopReferenceConfigBodyParam frinx.openconfig.bgp.policy.setcommunityreferencetop.reference.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetCommunityReferenceConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetcommunityreferencetopReferenceConfigBodyParam FrinxOpenconfigBgpPolicySetcommunityreferencetopReferenceConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-community/frinx-openconfig-bgp-policy:reference/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetcommunityreferencetopReferenceConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setextcommunityactiontop.SetExtCommunity
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetextcommunityactiontopSetExtCommunityBodyParam frinx.openconfig.bgp.policy.setextcommunityactiontop.SetExtCommunity to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunity(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetextcommunityactiontopSetExtCommunityBodyParam FrinxOpenconfigBgpPolicySetextcommunityactiontopSetExtCommunityRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetextcommunityactiontopSetExtCommunityBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setextcommunityactiontop.setextcommunity.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetextcommunityactiontopSetextcommunityConfigBodyParam frinx.openconfig.bgp.policy.setextcommunityactiontop.setextcommunity.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetextcommunityactiontopSetextcommunityConfigBodyParam FrinxOpenconfigBgpPolicySetextcommunityactiontopSetextcommunityConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetextcommunityactiontopSetextcommunityConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setextcommunityinlinetop.Inline
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetextcommunityinlinetopInlineBodyParam frinx.openconfig.bgp.policy.setextcommunityinlinetop.Inline to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityInline(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetextcommunityinlinetopInlineBodyParam FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:inline/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetextcommunityinlinetopInlineBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setextcommunityinlinetop.inline.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetextcommunityinlinetopInlineConfigBodyParam frinx.openconfig.bgp.policy.setextcommunityinlinetop.inline.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityInlineConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetextcommunityinlinetopInlineConfigBodyParam FrinxOpenconfigBgpPolicySetextcommunityinlinetopInlineConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:inline/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetextcommunityinlinetopInlineConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setextcommunityreferencetop.Reference
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceBodyParam frinx.openconfig.bgp.policy.setextcommunityreferencetop.Reference to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityReference(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceBodyParam FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:reference/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.setextcommunityreferencetop.reference.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceConfigBodyParam frinx.openconfig.bgp.policy.setextcommunityreferencetop.reference.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementActionsBgpActionsSetExtCommunityReferenceConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceConfigBodyParam FrinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:actions/frinx-openconfig-bgp-policy:bgp-actions/frinx-openconfig-bgp-policy:set-ext-community/frinx-openconfig-bgp-policy:reference/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicySetextcommunityreferencetopReferenceConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.bgpconditionstop.BgpConditions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyBgpconditionstopBgpConditionsBodyParam frinx.openconfig.bgp.policy.bgpconditionstop.BgpConditions to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditions(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyBgpconditionstopBgpConditionsBodyParam FrinxOpenconfigBgpPolicyBgpconditionstopBgpConditionsRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyBgpconditionstopBgpConditionsBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.aspathlengthtop.AsPathLength
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyAspathlengthtopAsPathLengthBodyParam frinx.openconfig.bgp.policy.aspathlengthtop.AsPathLength to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsAsPathLength(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyAspathlengthtopAsPathLengthBodyParam FrinxOpenconfigBgpPolicyAspathlengthtopAsPathLengthRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:as-path-length/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyAspathlengthtopAsPathLengthBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.aspathlengthtop.aspathlength.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyAspathlengthtopAspathlengthConfigBodyParam frinx.openconfig.bgp.policy.aspathlengthtop.aspathlength.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsAsPathLengthConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyAspathlengthtopAspathlengthConfigBodyParam FrinxOpenconfigBgpPolicyAspathlengthtopAspathlengthConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:as-path-length/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyAspathlengthtopAspathlengthConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.communitycounttop.CommunityCount
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyCommunitycounttopCommunityCountBodyParam frinx.openconfig.bgp.policy.communitycounttop.CommunityCount to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsCommunityCount(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyCommunitycounttopCommunityCountBodyParam FrinxOpenconfigBgpPolicyCommunitycounttopCommunityCountRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:community-count/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyCommunitycounttopCommunityCountBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.communitycounttop.communitycount.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyCommunitycounttopCommunitycountConfigBodyParam frinx.openconfig.bgp.policy.communitycounttop.communitycount.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsCommunityCountConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyCommunitycounttopCommunitycountConfigBodyParam FrinxOpenconfigBgpPolicyCommunitycounttopCommunitycountConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:community-count/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyCommunitycounttopCommunitycountConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.bgpconditionstop.bgpconditions.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyBgpconditionstopBgpconditionsConfigBodyParam frinx.openconfig.bgp.policy.bgpconditionstop.bgpconditions.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyBgpconditionstopBgpconditionsConfigBodyParam FrinxOpenconfigBgpPolicyBgpconditionstopBgpconditionsConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyBgpconditionstopBgpconditionsConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.matchaspathtop.MatchAsPathSet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyMatchaspathtopMatchAsPathSetBodyParam frinx.openconfig.bgp.policy.matchaspathtop.MatchAsPathSet to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchAsPathSet(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyMatchaspathtopMatchAsPathSetBodyParam FrinxOpenconfigBgpPolicyMatchaspathtopMatchAsPathSetRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-as-path-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyMatchaspathtopMatchAsPathSetBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.matchaspathtop.matchaspathset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyMatchaspathtopMatchaspathsetConfigBodyParam frinx.openconfig.bgp.policy.matchaspathtop.matchaspathset.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchAsPathSetConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyMatchaspathtopMatchaspathsetConfigBodyParam FrinxOpenconfigBgpPolicyMatchaspathtopMatchaspathsetConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-as-path-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyMatchaspathtopMatchaspathsetConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.matchcommunitytop.MatchCommunitySet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyMatchcommunitytopMatchCommunitySetBodyParam frinx.openconfig.bgp.policy.matchcommunitytop.MatchCommunitySet to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchCommunitySet(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyMatchcommunitytopMatchCommunitySetBodyParam FrinxOpenconfigBgpPolicyMatchcommunitytopMatchCommunitySetRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-community-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyMatchcommunitytopMatchCommunitySetBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.matchcommunitytop.matchcommunityset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyMatchcommunitytopMatchcommunitysetConfigBodyParam frinx.openconfig.bgp.policy.matchcommunitytop.matchcommunityset.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchCommunitySetConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyMatchcommunitytopMatchcommunitysetConfigBodyParam FrinxOpenconfigBgpPolicyMatchcommunitytopMatchcommunitysetConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-community-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyMatchcommunitytopMatchcommunitysetConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.matchextcommunitytop.MatchExtCommunitySet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyMatchextcommunitytopMatchExtCommunitySetBodyParam frinx.openconfig.bgp.policy.matchextcommunitytop.MatchExtCommunitySet to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchExtCommunitySet(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyMatchextcommunitytopMatchExtCommunitySetBodyParam FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchExtCommunitySetRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-ext-community-set/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyMatchextcommunitytopMatchExtCommunitySetBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
FrinxOpenconfigBgpPolicyApiService
creates or updates frinx.openconfig.bgp.policy.matchextcommunitytop.matchextcommunityset.Config
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Id of policy-definition
 * @param statementName Id of statement
 * @param frinxOpenconfigBgpPolicyMatchextcommunitytopMatchextcommunitysetConfigBodyParam frinx.openconfig.bgp.policy.matchextcommunitytop.matchextcommunityset.Config to be added or updated
 * @param nodeId


*/
func (a *FrinxOpenconfigBgpPolicyApiService) PutFrinxOpenconfigRoutingPolicyRoutingPolicyPolicyDefinitionsPolicyDefinitionStatementsStatementConditionsBgpConditionsMatchExtCommunitySetConfig(ctx context.Context, name string, statementName string, frinxOpenconfigBgpPolicyMatchextcommunitytopMatchextcommunitysetConfigBodyParam FrinxOpenconfigBgpPolicyMatchextcommunitytopMatchextcommunitysetConfigRequest, nodeId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/config/network-topology:network-topology/network-topology:topology/unified/network-topology:node/{node-id}/yang-ext:mount/frinx-openconfig-routing-policy:routing-policy/frinx-openconfig-routing-policy:policy-definitions/frinx-openconfig-routing-policy:policy-definition/{name}/frinx-openconfig-routing-policy:statements/frinx-openconfig-routing-policy:statement/{statement-name}/frinx-openconfig-routing-policy:conditions/frinx-openconfig-bgp-policy:bgp-conditions/frinx-openconfig-bgp-policy:match-ext-community-set/frinx-openconfig-bgp-policy:config/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"statement-name"+"}", fmt.Sprintf("%v", statementName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node-id"+"}", fmt.Sprintf("%v", nodeId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &frinxOpenconfigBgpPolicyMatchextcommunitytopMatchextcommunitysetConfigBodyParam
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
